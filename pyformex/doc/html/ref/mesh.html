

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<!-- 
##
##  This file is part of the pyFormex project.
##  pyFormex is a tool for generating, manipulating and transforming 3D
##  geometrical models by sequences of mathematical operations.
##  Home page: http://pyformex.org
##  Project page:  http://savannah.nongnu.org/projects/pyformex/
##  Copyright (C) Benedict Verhegghe (benedict.verhegghe@ugent.be) 
##  Distributed under the GNU General Public License version 3 or later.
##
##
##  This program is free software: you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation, either version 3 of the License, or
##  (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program.  If not, see http://www.gnu.org/licenses/.
##
-->


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>7. mesh — Finite element meshes in pyFormex. &mdash; pyFormex 1.0.2-a6 documentation</title>

    
    <link rel="stylesheet" href="../_static/pyformex.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0.2-a6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="pyFormex 1.0.2-a6 documentation" href="../index.html" />
    <link rel="up" title="pyFormex reference manual" href="../refman.html" />
    <link rel="next" title="8. geometry — A generic interface to the Coords transformation methods" href="geometry.html" />
    <link rel="prev" title="6. opengl.colors — Playing with colors." href="opengl.colors.html" />
<link rel="icon" type="image/png" href="_static/pyformex_fav.png" />

  </head>
  <body role="document">

<div class="header">
  <a href="http://pyformex.org">
  <img src="http://www.nongnu.org/pyformex/_static/scallop_dome_small.png" alt="scallop dome" border="0" hspace="20" vspace="12" align="left" />
  <img src="http://www.nongnu.org/pyformex/_static/pyformex-logo-2.png" alt="pyformex logo" border="0" hspace="10" vspace="8" align="left" />
  </a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="geometry.html" title="8. geometry — A generic interface to the Coords transformation methods"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="opengl.colors.html" title="6. opengl.colors — Playing with colors."
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">pyFormex 1.0.2-a6 documentation</a> &gt;</li>
          <li class="nav-item nav-item-1"><a href="../refman.html" accesskey="U">pyFormex reference manual</a> &gt;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div align="center">

<form action="https://www.paypal.com/cgi-bin/webscr" method="post">
<input type="hidden" name="cmd" value="_s-xclick"/>
<input type="hidden" name="hosted_button_id" value="P7J4AM4QULB4Q"/>
<input type="image" src="https://www.paypal.com/en_US/BE/i/btn/btn_donateCC_LG.gif" name="submit" alt="PayPal - The safer, easier way to pay online!"/>
<img alt="" border="0" src="https://www.paypal.com/nl_NL/i/scr/pixel.gif" width="1" height="1"/>
</form>

</div>
   
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">7. <code class="docutils literal"><span class="pre">mesh</span></code> &#8212; Finite element meshes in pyFormex.</a><ul>
<li><a class="reference internal" href="#classes-defined-in-module-mesh">7.1. Classes defined in module mesh</a></li>
<li><a class="reference internal" href="#functions-defined-in-module-mesh">7.2. Functions defined in module mesh</a></li>
</ul>
</li>
</ul>


  <h4>Previous topic</h4>
  <p class="topless"><a href="opengl.colors.html"
                        title="previous chapter">6. <code class="docutils literal"><span class="pre">opengl.colors</span></code> &#8212; Playing with colors.</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="geometry.html"
                        title="next chapter">8. <code class="docutils literal"><span class="pre">geometry</span></code> &#8212; A generic interface to the Coords transformation methods</a></p>
  
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>

<div align="center">
  <p>
  <a href="http://www.fsf.org/register_form?referrer=8491"><img src="http://www.nongnu.org/pyformex/_static/fsf-member8491.png" alt="[FSF Associate Member]" width="89" height="31"  /></a>
  </p>
  <p>
    <a href="http://validator.w3.org/check?uri=referer"><img
      src="http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0 Transitional" height="31" width="88" /></a>
  </p>
</div>

        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-mesh">
<span id="mesh-finite-element-meshes-in-pyformex"></span><span id="sec-ref-mesh"></span><h1>7. <a class="reference internal" href="#module-mesh" title="mesh: Finite element meshes in pyFormex."><code class="xref py py-mod docutils literal"><span class="pre">mesh</span></code></a> &#8212; Finite element meshes in pyFormex.<a class="headerlink" href="#module-mesh" title="Permalink to this headline">¶</a></h1>
<p>This module defines the Mesh class, which can be used to describe discrete
geometrical models like those used in Finite Element models.
It also contains some useful functions to create such models.</p>
<div class="section" id="classes-defined-in-module-mesh">
<h2>7.1. Classes defined in module mesh<a class="headerlink" href="#classes-defined-in-module-mesh" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="mesh.Mesh">
<em class="property">class </em><code class="descclassname">mesh.</code><code class="descname">Mesh</code><span class="sig-paren">(</span><em>coords=None</em>, <em>elems=None</em>, <em>prop=None</em>, <em>eltype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>A Mesh is a discrete geometrical model defined by nodes and elements.</p>
<p>In the Mesh geometrical data model, the coordinates of all the points
are gathered in a single twodimensional array with shape (ncoords,3).
The individual geometrical elements are then described by indices into
the coordinates array.</p>
<p>This model has some advantages over the Formex data model (which stores
all the points of all the elements by their coordinates):</p>
<ul class="simple">
<li>a more compact storage, because coordinates of coinciding
points are not repeated,</li>
<li>faster connectivity related algorithms.</li>
</ul>
<p>The downside is that geometry generating algorithms are far more complex
and possibly slower.</p>
<p>In pyFormex we therefore mostly use the Formex data model when creating
geometry, but when we come to the point of exporting the geometry to
file (and to other programs), a Mesh data model may be more adequate.</p>
<p>The Mesh data model has at least the following attributes:</p>
<ul class="simple">
<li><cite>coords</cite>: (ncoords,3) shaped Coords object, holding the coordinates of
all points in the Mesh;</li>
<li><cite>elems</cite>: (nelems,nplex) shaped Connectivity object, defining the elements
by indices into the Coords array. All values in elems should be in the
range 0 &lt;= value &lt; ncoords.</li>
<li><cite>prop</cite>: an array of element property numbers, default None.</li>
<li><cite>eltype</cite>: an element type (a subclass of <code class="xref py py-class docutils literal"><span class="pre">Element</span></code>) or the name
of an Element type, or None (default).
If eltype is None, the eltype of the elems Connectivity table is used,
and if that is missing, a default eltype is derived from the plexitude,
by a call to <a class="reference internal" href="elements.html#elements.elementType" title="elements.elementType"><code class="xref py py-func docutils literal"><span class="pre">elements.elementType()</span></code></a>.
In most cases the eltype can be set automatically.
The user can override the default value, but an error will occur if
the element type does not exist or does not match the plexitude.</li>
</ul>
<p>A Mesh can be initialized by its attributes (coords,elems,prop,eltype)
or by a single geometric object that provides a toMesh() method.</p>
<p>If only an element type is provided, a unit sized single element Mesh
of that type is created. Without parameters, an empty Mesh is created.</p>
<dl class="method">
<dt id="mesh.Mesh.setType">
<code class="descname">setType</code><span class="sig-paren">(</span><em>eltype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.setType" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the eltype from a character string.</p>
<p>This function allows the user to change the element type of the Mesh.
The input is a character string with the name of one of the element
defined in elements.py. The function will only allow to set a type
matching the plexitude of the Mesh.</p>
<p>This method is seldom needed, because the applications should
normally set the element type at creation time.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.elType">
<code class="descname">elType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.elType" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the element type of the Mesh.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.elName">
<code class="descname">elName</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.elName" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the element name of the Mesh.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.setNormals">
<code class="descname">setNormals</code><span class="sig-paren">(</span><em>normals=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.setNormals" title="Permalink to this definition">¶</a></dt>
<dd><p>Set/Remove the normals of the mesh.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.getProp">
<code class="descname">getProp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.getProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the properties as a numpy array (ndarray)</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.maxProp">
<code class="descname">maxProp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.maxProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the highest property value used, or None</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.propSet">
<code class="descname">propSet</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.propSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list with unique property values.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.shallowCopy">
<code class="descname">shallowCopy</code><span class="sig-paren">(</span><em>prop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.shallowCopy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a shallow copy.</p>
<p>A shallow copy of a Mesh is a Mesh object using the same data arrays
as the original Mesh. The only thing that can be changed is the
property array. This is a convenient method to use the same Mesh
with different property attributes.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.toFormex">
<code class="descname">toFormex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.toFormex" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a Mesh to a Formex.</p>
<p>The Formex inherits the element property numbers and eltype from
the Mesh. Node property numbers however can not be translated to
the Formex data model.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.toMesh">
<code class="descname">toMesh</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.toMesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a Mesh.</p>
<p>This just returns the Mesh object itself. It is provided as a
convenience for use in functions that want work on different Geometry
types.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.toSurface">
<code class="descname">toSurface</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.toSurface" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a Mesh to a TriSurface.</p>
<p>Only Meshes of level 2 (surface) and 3 (volume) can be converted to a
TriSurface. For a level 3 Mesh, the border Mesh is taken first.
A level 2 Mesh is converted to element type &#8216;tri3&#8217; and then to a
TriSurface.
The resulting TriSurface is only fully equivalent with the input
Mesh if the latter has element type &#8216;tri3&#8217;.</p>
<p>On success, returns a TriSurface corresponding with the input Mesh.
If the Mesh can not be converted to a TriSurface, an error is raised.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.toCurve">
<code class="descname">toCurve</code><span class="sig-paren">(</span><em>connect=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.toCurve" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a Mesh to a Curve.</p>
<p>If the element type is one of &#8216;line*&#8217; types, the Mesh is converted
to a Curve. The type of the returned Curve is dependent on the
element type of the Mesh:</p>
<ul class="simple">
<li>&#8216;line2&#8217;: PolyLine,</li>
<li>&#8216;line3&#8217;: BezierSpline (degree 2),</li>
<li>&#8216;line4&#8217;: BezierSpline (degree 3)</li>
</ul>
<p>If connect is False, this is equivalent with</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">toFormex</span><span class="p">()</span><span class="o">.</span><span class="n">toCurve</span><span class="p">()</span>
</pre></div>
</div>
<p>Any other type will raise an exception.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.level">
<code class="descname">level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.level" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the level of the elements in the Mesh</p>
<p>Returns the dimensionality of the elements: 0 (point), 1(line),
2 (surface), 3 (volume).</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.nelems">
<code class="descname">nelems</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.nelems" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of elements in the Mesh</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.nplex">
<code class="descname">nplex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.nplex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the plexitude of the elements in the Mesh</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.ncoords">
<code class="descname">ncoords</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.ncoords" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of nodes in the Mesh</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.nnodes">
<code class="descname">nnodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.nnodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of nodes in the Mesh</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.npoints">
<code class="descname">npoints</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.npoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of nodes in the Mesh</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.nedges">
<code class="descname">nedges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.nedges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of edges.</p>
<p>This returns the number of rows that would be in getEdges(),
without actually constructing the edges.
The edges are not fused!</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.info">
<code class="descname">info</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.info" title="Permalink to this definition">¶</a></dt>
<dd><p>Return short info about the Mesh.</p>
<p>This includes only the shape of the coords and elems arrays.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.report">
<code class="descname">report</code><span class="sig-paren">(</span><em>full=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.report" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a report on the Mesh shape and size.</p>
<p>The report always contains the number of nodes, number of elements,
plexitude, dimensionality, element type, bbox and size.
If full==True(default), it also contains the nodal coordinate
list and element connectivity table. Because the latter can be rather
bulky, they can be switched off. (Though numpy will limit the printed
output).</p>
<p>TODO: We should add an option here to let numpy print the full tables.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.centroids">
<code class="descname">centroids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.centroids" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the centroids of all elements of the Mesh.</p>
<p>The centroid of an element is the point whose coordinates
are the mean values of all points of the element.
The return value is a Coords object with nelems points.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.bboxes">
<code class="descname">bboxes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.bboxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the bboxes of all elements in the Mesh.</p>
<p>Returns a coords with shape (nelems,2,3). Along the axis 1
are stored the minimal and maximal values of the Coords
in each of the elements of the Mesh.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.getCoords">
<code class="descname">getCoords</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.getCoords" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the coords data.</p>
<p>Returns the full array of coordinates stored in the Mesh object.
Note that this may contain points that are not used in the mesh.
<a class="reference internal" href="#mesh.Mesh.compact" title="mesh.Mesh.compact"><code class="xref py py-meth docutils literal"><span class="pre">compact()</span></code></a> will remove the unused points.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.getElems">
<code class="descname">getElems</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.getElems" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the elems data.</p>
<p>Returns the element connectivity data as stored in the object.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.getLowerEntities">
<code class="descname">getLowerEntities</code><span class="sig-paren">(</span><em>level=-1</em>, <em>unique=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.getLowerEntities" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the entities of a lower dimensionality.</p>
<p>If the element type is defined in the <a class="reference internal" href="elements.html#module-elements" title="elements: Definition of elements."><code class="xref py py-mod docutils literal"><span class="pre">elements</span></code></a> module,
this returns a Connectivity table with the entities of a lower
dimensionality. The full list of entities with increasing
dimensionality  0,1,2,3 is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">,</span> <span class="s1">&#39;edges&#39;</span><span class="p">,</span> <span class="s1">&#39;faces&#39;</span><span class="p">,</span> <span class="s1">&#39;cells&#39;</span> <span class="p">]</span>
</pre></div>
</div>
<p>If level is negative, the dimensionality returned is relative
to that of the caller. If it is positive, it is taken absolute.
Thus, for a Mesh with a 3D element type, getLowerEntities(-1)
returns the faces, while for a 2D element type, it returns the edges.
For both meshes however,  getLowerEntities(+1) returns the edges.</p>
<p>By default, all entities for all elements are returned and common
entities will appear multiple times. Specifying unique=True will
return only the unique ones.</p>
<p>The return value may be an empty table, if the element type does
not have the requested entities (e.g. the &#8216;point&#8217; type).
If the eltype is not defined, or the requested entity level is
outside the range 0..3, the return value is None.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.getNodes">
<code class="descname">getNodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.getNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the set of unique node numbers in the Mesh.</p>
<p>This returns only the node numbers that are effectively used in
the connectivity table. For a compacted Mesh, it is equivalent to
<code class="docutils literal"><span class="pre">arange(self.nelems)</span></code>.
This function also stores the result internally so that future
requests can return it without the need for computing it again.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.getPoints">
<code class="descname">getPoints</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.getPoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the nodal coordinates of the Mesh.</p>
<p>This returns only those points that are effectively used in
the connectivity table. For a compacted Mesh, it is equal to
the coords attribute.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.getEdges">
<code class="descname">getEdges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.getEdges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unique edges of all the elements in the Mesh.</p>
<p>This is a convenient function to create a table with the element
edges. It is equivalent to <code class="docutils literal"><span class="pre">self.getLowerEntities(1,unique=True)</span></code>,
but this also stores the result internally so that future
requests can return it without the need for computing it again.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.getFaces">
<code class="descname">getFaces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.getFaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unique faces of all the elements in the Mesh.</p>
<p>This is a convenient function to create a table with the element
faces. It is equivalent to <code class="docutils literal"><span class="pre">self.getLowerEntities(2,unique=True)</span></code>,
but this also stores the result internally so that future
requests can return it without the need for computing it again.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.getCells">
<code class="descname">getCells</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.getCells" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cells of the elements.</p>
<p>This is a convenient function to create a table with the element
cells. It is equivalent to <code class="docutils literal"><span class="pre">self.getLowerEntities(3,unique=True)</span></code>,
but this also stores the result internally so that future
requests can return it without the need for computing it again.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.edgeMesh">
<code class="descname">edgeMesh</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.edgeMesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Mesh with the unique edges of the elements.</p>
<p>This can only be used with a Mesh of level &gt;= 1.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.faceMesh">
<code class="descname">faceMesh</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.faceMesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Mesh with the unique faces of the elements.</p>
<p>This can only be used with a Mesh of level &gt;= 2.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.getElemEdges">
<code class="descname">getElemEdges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.getElemEdges" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the elements in function of its edges.</p>
<p>This returns a Connectivity table with the elements defined in
function of the edges. It returns the equivalent of
<code class="docutils literal"><span class="pre">self.elems.insertLevel(self.elType().getEntities(1))</span></code>
but as a side effect it also stores the definition of the edges
and the returned element to edge connectivity in the attributes
<cite>edges</cite>, resp. <cite>elem_edges</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.getFreeEntities">
<code class="descname">getFreeEntities</code><span class="sig-paren">(</span><em>level=-1</em>, <em>return_indices=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.getFreeEntities" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the border of the Mesh.</p>
<p>Returns a Connectivity table with the free entities of the
specified level of the Mesh. Free entities are entities
that are only connected to a single element.</p>
<p>If return_indices==True, also returns an (nentities,2) index
for inverse lookup of the higher entity (column 0) and its local
lower entity number (column 1).</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.getFreeEntitiesMesh">
<code class="descname">getFreeEntitiesMesh</code><span class="sig-paren">(</span><em>level=-1</em>, <em>compact=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.getFreeEntitiesMesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Mesh with lower entities.</p>
<p>Returns a Mesh representing the lower entities of the specified
level. If the Mesh has property numbers, the lower entities inherit
the property of the element to which they belong.</p>
<p>By default, the resulting Mesh is compacted. Compaction can be
switched off by setting <cite>compact=False</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.getBorder">
<code class="descname">getBorder</code><span class="sig-paren">(</span><em>return_indices=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.getBorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the border of the Mesh.</p>
<p>This returns a Connectivity table with the border of the Mesh.
The border entities are of a lower hierarchical level than the
mesh itself. These entities become part of the border if they
are connected to only one element.</p>
<p>If return_indices==True, it returns also an (nborder,2) index
for inverse lookup of the higher entity (column 0) and its local
border part number (column 1).</p>
<p>This is a convenient shorthand for</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">getFreeEntities</span><span class="p">(</span><span class="n">level</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">return_indices</span><span class="o">=</span><span class="n">return_indices</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.getBorderMesh">
<code class="descname">getBorderMesh</code><span class="sig-paren">(</span><em>compact=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.getBorderMesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Mesh with the border elements.</p>
<p>The returned Mesh is of the next lower hierarchical level and
contains all the free entitites of that level.
If the Mesh has property numbers, the border elements inherit
the property of the element to which they belong.</p>
<p>By default, the resulting Mesh is compacted. Compaction can be
switched off by setting <cite>compact=False</cite>.</p>
<p>This is a convenient shorthand for</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">getFreeEntitiesMesh</span><span class="p">(</span><span class="n">level</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">compact</span><span class="o">=</span><span class="n">compact</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.borderMesh">
<code class="descname">borderMesh</code><span class="sig-paren">(</span><em>compact=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.borderMesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Mesh with the border elements.</p>
<p>The returned Mesh is of the next lower hierarchical level and
contains all the free entitites of that level.
If the Mesh has property numbers, the border elements inherit
the property of the element to which they belong.</p>
<p>By default, the resulting Mesh is compacted. Compaction can be
switched off by setting <cite>compact=False</cite>.</p>
<p>This is a convenient shorthand for</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">getFreeEntitiesMesh</span><span class="p">(</span><span class="n">level</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">compact</span><span class="o">=</span><span class="n">compact</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.getBorderElems">
<code class="descname">getBorderElems</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.getBorderElems" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the elements that are on the border of the Mesh.</p>
<p>This returns a list with the numbers of the elements that are on the
border of the Mesh. Elements are considered to be at the border if they
contain at least one complete element of the border Mesh (i.e. an
element of the first lower hierarchical level). Thus, in a volume Mesh,
elements only touching the border by a vertex or an edge are not
considered border elements.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.getBorderNodes">
<code class="descname">getBorderNodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.getBorderNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the nodes that are on the border of the Mesh.</p>
<p>This returns a list with the numbers of the nodes that are on the
border of the Mesh.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.peel">
<code class="descname">peel</code><span class="sig-paren">(</span><em>nodal=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.peel" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Mesh with the border elements removed.</p>
<p>If nodal is True all elements connected to a border node are removed.
If nodal is False, it is a convenient shorthand for</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">cselect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getBorderElems</span><span class="p">())</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.getFreeEdgesMesh">
<code class="descname">getFreeEdgesMesh</code><span class="sig-paren">(</span><em>compact=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.getFreeEdgesMesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Mesh with the free edge elements.</p>
<p>The returned Mesh is of the hierarchical level 1 (no mather what
the level of the parent Mesh is) and contains all the free entitites
of that level.
If the Mesh has property numbers, the border elements inherit
the property of the element to which they belong.</p>
<p>By default, the resulting Mesh is compacted. Compaction can be
switched off by setting <cite>compact=False</cite>.</p>
<p>This is a convenient shorthand for</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">getFreeEntitiesMesh</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">compact</span><span class="o">=</span><span class="n">compact</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.connectedTo">
<code class="descname">connectedTo</code><span class="sig-paren">(</span><em>*_args</em>, <em>**_kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.connectedTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Select the elements connected to specific lower entities.</p>
<p><cite>entities</cite>: int or array_like, int. Entity selector.
<cite>level</cite>: int. Entity level. Default 0 (nodes).</p>
<p>Returns a list of the numbers of the elements that contain at
least one of the specified lower entities.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.adjacentTo">
<code class="descname">adjacentTo</code><span class="sig-paren">(</span><em>elements</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.adjacentTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Select the elements adjacent to the specified elements.</p>
<p><cite>elements</cite>: int or array_like, int. Element selector.
<cite>level</cite>: int. Entity level used to define adjacency. Default 0 (nodes).</p>
<p>Returns a list of all the elements in the Mesh adjacent
to any of the specified elements. The adjacency is defined
over nodes, edges or faces, depending on the <cite>level</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.reachableFrom">
<code class="descname">reachableFrom</code><span class="sig-paren">(</span><em>elements</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.reachableFrom" title="Permalink to this definition">¶</a></dt>
<dd><p>Select the elements reachable from the specified elements.</p>
<ul class="simple">
<li><cite>elements</cite>: int or array_like, int. Element selector.</li>
<li><cite>level</cite>: int. Specify how elements can be reached:
via node (0), edge (1) or face (2).</li>
</ul>
<p>Returns a list of all the elements in the Mesh reachable from
any of the specified elements by walking over entities of the
specified level. The list will include the original set of elements.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.adjacency">
<code class="descname">adjacency</code><span class="sig-paren">(</span><em>level=0</em>, <em>diflevel=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.adjacency" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an element adjacency table.</p>
<p>Two elements are said to be adjacent if they share a lower
entity of the specified level.
The level is one of the lower entities of the mesh.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>level</cite>: hierarchy of the geometric items connecting two elements:
0 = node, 1 = edge, 2 = face. Only values of a lower hierarchy than
the elements of the Mesh itself make sense.</li>
<li><cite>diflevel</cite>: if &gt;= level, and smaller than the hierarchy of
self.elems, elements that have a connection of this level are removed.
Thus, in a Mesh with volume elements, self.adjacency(0,1) gives the
adjacency of elements by a node but not by an edge.</li>
</ul>
<p>Returns an Adjacency with integers specifying for each element
its neighbours connected by the specified geometrical subitems.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.frontWalk">
<code class="descname">frontWalk</code><span class="sig-paren">(</span><em>level=0</em>, <em>startat=0</em>, <em>frontinc=1</em>, <em>partinc=1</em>, <em>maxval=-1</em>, <em>optim_mem=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.frontWalk" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit all elements using a frontal walk.</p>
<p>In a frontal walk a forward step is executed simultanuously from all
the elements in the current front. The elements thus reached become
the new front. An element can be reached from the current element if
both are connected by a lower entity of the specified level. Default
level is &#8216;point&#8217;.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>level</cite>: hierarchy of the geometric items connecting two elements:
0 = node, 1 = edge, 2 = face. Only values of a lower hierarchy than
the elements of the Mesh itself make sense. There are no
connections on the upper level.</li>
</ul>
<p>The remainder of the parameters are like in
<code class="xref py py-meth docutils literal"><span class="pre">Adjacency.frontWalk()</span></code>.</p>
<p>Returns an array of integers specifying for each element in which step
the element was reached by the walker.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.maskedEdgeFrontWalk">
<code class="descname">maskedEdgeFrontWalk</code><span class="sig-paren">(</span><em>mask=None</em>, <em>startat=0</em>, <em>frontinc=1</em>, <em>partinc=1</em>, <em>maxval=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.maskedEdgeFrontWalk" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a front walk over masked edge connections.</p>
<p>This is like frontWalk(level=1), but allows to specify a mask to
select the edges that are used as connectors between elements.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>mask</cite>: Either None or a boolean array or index flagging the nodes
which are to be considered connectors between elements. If None,
all nodes are considered connections.</li>
</ul>
<p>The remainder of the parameters are like in
<code class="xref py py-meth docutils literal"><span class="pre">Adjacency.frontWalk()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.partitionByConnection">
<code class="descname">partitionByConnection</code><span class="sig-paren">(</span><em>level=0</em>, <em>startat=0</em>, <em>sort='number'</em>, <em>nparts=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.partitionByConnection" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect the connected parts of a Mesh.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>sort</cite>: str. Weighted sorting method. It can assume values
&#8216;number&#8217; (default), &#8216;length&#8217;, &#8216;area&#8217;, &#8216;volume&#8217;.</li>
<li><cite>nparts</cite>: is the equivalent of parameter <cite>maxval</cite> in
<a class="reference internal" href="#mesh.Mesh.frontWalk" title="mesh.Mesh.frontWalk"><code class="xref py py-meth docutils literal"><span class="pre">Mesh.frontWalk()</span></code></a>.
Maximum frontal value. If negative (default) the walk will
continue until all elements have been reached. If non-negative,
walking will stop as soon as the frontal value reaches this
maximum.</li>
</ul>
<p>The remainder of the parameters are like in
<a class="reference internal" href="#mesh.Mesh.frontWalk" title="mesh.Mesh.frontWalk"><code class="xref py py-meth docutils literal"><span class="pre">Mesh.frontWalk()</span></code></a>.</p>
<p>The Mesh is partitioned in parts in which all elements are
connected. Two elements are connected if it is possible to draw a
continuous (poly)line from a point in one element to a point in
the other element without leaving the Mesh.
The partitioning is returned as a integer array having a value
for each element corresponding to the part number it belongs to.</p>
<p>By default the parts are sorted in decreasing order of the number
of elements. If you specify nparts, you may wish to switch off the
sorting by specifying sort=&#8217;&#8216;.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.splitByConnection">
<code class="descname">splitByConnection</code><span class="sig-paren">(</span><em>level=0</em>, <em>startat=0</em>, <em>sort='number'</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.splitByConnection" title="Permalink to this definition">¶</a></dt>
<dd><p>Split the Mesh into connected parts.</p>
<p>The parameters <cite>level</cite> and <cite>startat</cite> are like in
<a class="reference internal" href="#mesh.Mesh.frontWalk" title="mesh.Mesh.frontWalk"><code class="xref py py-meth docutils literal"><span class="pre">Mesh.frontWalk()</span></code></a>.
The parameter <cite>sort</cite> is like in
<a class="reference internal" href="#mesh.Mesh.partitionByConnection" title="mesh.Mesh.partitionByConnection"><code class="xref py py-meth docutils literal"><span class="pre">Mesh.partitionByConnection()</span></code></a>.</p>
<p>Returns a list of Meshes that each form a connected part.
By default the parts are sorted in decreasing order of the number
of elements.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.largestByConnection">
<code class="descname">largestByConnection</code><span class="sig-paren">(</span><em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.largestByConnection" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the largest connected part of the Mesh.</p>
<p>This is equivalent with, but more efficient than</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">splitByConnection</span><span class="p">(</span><span class="n">level</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.growSelection">
<code class="descname">growSelection</code><span class="sig-paren">(</span><em>sel</em>, <em>mode='node'</em>, <em>nsteps=1</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.growSelection" title="Permalink to this definition">¶</a></dt>
<dd><p>Grow a selection of a surface.</p>
<p><cite>p</cite> is a single element number or a list of numbers.
The return value is a list of element numbers obtained by
growing the front <cite>nsteps</cite> times.
The <cite>mode</cite> argument specifies how a single frontal step is done:</p>
<ul class="simple">
<li>&#8216;node&#8217; : include all elements that have a node in common,</li>
<li>&#8216;edge&#8217; : include all elements that have an edge in common.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.partitionByAngle">
<code class="descname">partitionByAngle</code><span class="sig-paren">(</span><em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.partitionByAngle" title="Permalink to this definition">¶</a></dt>
<dd><p>Partition a level-2 Mesh by the angle between adjacent elements.</p>
<p>The Mesh is partitioned in parts bounded by the sharp edges in the
surface. The arguments and return value are the same as in
<code class="xref py py-meth docutils literal"><span class="pre">TriSurface.partitionByAngle()</span></code>.</p>
<p>For eltypes other than &#8216;tri3&#8217;,
a conversion to &#8216;tri3&#8217; is done before computing the partitions.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.nodeConnections">
<code class="descname">nodeConnections</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.nodeConnections" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and store the elems connected to nodes.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.nNodeConnected">
<code class="descname">nNodeConnected</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.nNodeConnected" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the number of elems connected to nodes.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.edgeConnections">
<code class="descname">edgeConnections</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.edgeConnections" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and store the elems connected to edges.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.nEdgeConnected">
<code class="descname">nEdgeConnected</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.nEdgeConnected" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the number of elems connected to edges.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.nodeAdjacency">
<code class="descname">nodeAdjacency</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.nodeAdjacency" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the elems adjacent to each elem via one or more nodes.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.nNodeAdjacent">
<code class="descname">nNodeAdjacent</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.nNodeAdjacent" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the number of elems which are adjacent by node to each elem.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.edgeAdjacency">
<code class="descname">edgeAdjacency</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.edgeAdjacency" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the elems adjacent to elems via an edge.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.nEdgeAdjacent">
<code class="descname">nEdgeAdjacent</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.nEdgeAdjacent" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the number of adjacent elems.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.nonManifoldNodes">
<code class="descname">nonManifoldNodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.nonManifoldNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the non-manifold nodes of a Mesh.</p>
<p>Non-manifold nodes are nodes where subparts of a mesh of level &gt;= 2
are connected by a node but not by an edge.</p>
<p>Returns an integer array with a sorted list of non-manifold node
numbers. Possibly empty (always if the dimensionality of the Mesh
is lower than 2).</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.nonManifoldEdges">
<code class="descname">nonManifoldEdges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.nonManifoldEdges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the non-manifold edges of a Mesh.</p>
<p>Non-manifold edges are edges where subparts of a mesh of level 3
are connected by an edge but not by an face.</p>
<p>Returns an integer array with a sorted list of non-manifold edge
numbers. Possibly empty (always if the dimensionality of the Mesh
is lower than 3).</p>
<p>As a side effect, this constructs the list of edges in the object.
The definition of the nonManifold edges in terms of the nodes can
thus be got from</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nonManifoldEdges</span><span class="p">()]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.nonManifoldEdgeNodes">
<code class="descname">nonManifoldEdgeNodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.nonManifoldEdgeNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the non-manifold edge nodes of a Mesh.</p>
<p>Non-manifold edges are edges where subparts of a mesh of level 3
are connected by an edge but not by an face.</p>
<p>Returns an integer array with a sorted list of numbers of nodes
on the non-manifold edges.
Possibly empty (always if the dimensionality of the Mesh
is lower than 3).</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.fuse">
<code class="descname">fuse</code><span class="sig-paren">(</span><em>parts=None</em>, <em>nodes=None</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.fuse" title="Permalink to this definition">¶</a></dt>
<dd><p>Fuse the nodes of a Meshes.</p>
<p>Nodes that are within the tolerance limits of each other
are merged into a single node.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>parts</cite>: int array-like with length equal to number of elements.
If specified, it will be used to split the Mesh into parts (see
<a class="reference internal" href="#mesh.Mesh.splitProp" title="mesh.Mesh.splitProp"><code class="xref py py-func docutils literal"><span class="pre">splitProp()</span></code></a>) and do the fuse operation per part.
Elements for which the value of <cite>nparts</cite> is negative will not
be involved in the fuse operations.</li>
<li><cite>nodes</cite>: int array-like: a list of nod numbers. If specified,
only these nodes will be involved in the fuse operation. This
option can not be specified together when the <cite>parts</cite> option
is used.</li>
<li>Extra arguments for tuning the fuse operation are passed to the
<code class="xref py py-meth docutils literal"><span class="pre">Coords:fuse()</span></code> method.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.matchCoords">
<code class="descname">matchCoords</code><span class="sig-paren">(</span><em>coords</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.matchCoords" title="Permalink to this definition">¶</a></dt>
<dd><p>Match nodes of coords with nodes of self.</p>
<p>coords can be a Coords or a Mesh object
This is a convenience function equivalent to</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span><span class="o">**</span><span class="n">kargs</span><span class="p">)</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span><span class="o">**</span><span class="n">kargs</span><span class="p">)</span>
</pre></div>
</div>
<p>See also <code class="xref py py-meth docutils literal"><span class="pre">Coords.match()</span></code></p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.matchCentroids">
<code class="descname">matchCentroids</code><span class="sig-paren">(</span><em>mesh</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.matchCentroids" title="Permalink to this definition">¶</a></dt>
<dd><p>Match elems of Mesh with elems of self.</p>
<p>self and Mesh are same eltype meshes
and are both without duplicates.</p>
<p>Elems are matched by their centroids.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.compact">
<code class="descname">compact</code><span class="sig-paren">(</span><em>return_index=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.compact" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove unconnected nodes and renumber the mesh.</p>
<p>Returns a mesh where all nodes that are not used in any
element have been removed, and the nodes are renumbered to
a compacter scheme.</p>
<p>If return_index is True, also returns an index specifying the
index of the new nodes in the old node scheme.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">(</span><span class="n">x</span><span class="p">,[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="p">,</span><span class="n">ind</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">compact</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
<span class="go">[[ 0.  0.  0.]</span>
<span class="go"> [ 1.  0.  0.]</span>
<span class="go"> [ 2.  0.  0.]</span>
<span class="go"> [ 4.  0.  0.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">elems</span><span class="p">)</span>
<span class="go">[[0 2]</span>
<span class="go"> [1 3]</span>
<span class="go"> [3 2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">(</span><span class="n">x</span><span class="p">,[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">compact</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
<span class="go">[[ 0.  0.  0.]</span>
<span class="go"> [ 1.  0.  0.]</span>
<span class="go"> [ 2.  0.  0.]</span>
<span class="go"> [ 3.  0.  0.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">elems</span><span class="p">)</span>
<span class="go">[[0 2]</span>
<span class="go"> [1 3]</span>
<span class="go"> [3 2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
<span class="go">[0 1 2 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.avgNodes">
<code class="descname">avgNodes</code><span class="sig-paren">(</span><em>nodsel</em>, <em>wts=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.avgNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Create average nodes from the existing nodes of a mesh.</p>
<p><cite>nodsel</cite> is a local node selector as in <a class="reference internal" href="#mesh.Mesh.selectNodes" title="mesh.Mesh.selectNodes"><code class="xref py py-meth docutils literal"><span class="pre">selectNodes()</span></code></a>
Returns the (weighted) average coordinates of the points in the
selector as <cite>(nelems*nnod,3)</cite> array of coordinates, where
nnod is the length of the node selector.
<cite>wts</cite> is a 1-D array of weights to be attributed to the points.
Its length should be equal to that of nodsel.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.meanNodes">
<code class="descname">meanNodes</code><span class="sig-paren">(</span><em>nodsel</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.meanNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Create nodes from the existing nodes of a mesh.</p>
<p><cite>nodsel</cite> is a local node selector as in <a class="reference internal" href="#mesh.Mesh.selectNodes" title="mesh.Mesh.selectNodes"><code class="xref py py-meth docutils literal"><span class="pre">selectNodes()</span></code></a>
Returns the mean coordinates of the points in the selector as
<cite>(nelems*nnod,3)</cite> array of coordinates, where nnod is the length
of the node selector.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.addNodes">
<code class="descname">addNodes</code><span class="sig-paren">(</span><em>newcoords</em>, <em>eltype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.addNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Add new nodes to elements.</p>
<p><cite>newcoords</cite> is an <cite>(nelems,nnod,3)</cite> or`(nelems*nnod,3)` array of
coordinates. Each element gets exactly <cite>nnod</cite> extra nodes from this
array. The result is a Mesh with plexitude <cite>self.nplex() + nnod</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.addMeanNodes">
<code class="descname">addMeanNodes</code><span class="sig-paren">(</span><em>nodsel</em>, <em>eltype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.addMeanNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Add new nodes to elements by averaging existing ones.</p>
<p><cite>nodsel</cite> is a local node selector as in <a class="reference internal" href="#mesh.Mesh.selectNodes" title="mesh.Mesh.selectNodes"><code class="xref py py-meth docutils literal"><span class="pre">selectNodes()</span></code></a>
Returns a Mesh where the mean coordinates of the points in the
selector are added to each element, thus increasing the plexitude
by the length of the items in the selector.
The new element type should be set to correct value.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.selectNodes">
<code class="descname">selectNodes</code><span class="sig-paren">(</span><em>nodsel</em>, <em>eltype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.selectNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a mesh with subsets of the original nodes.</p>
<p><cite>nodsel</cite> is an object that can be converted to a 1-dim or 2-dim
array. Examples are a tuple of local node numbers, or a list
of such tuples all having the same length.
Each row of <cite>nodsel</cite> holds a list of local node numbers that
should be retained in the new connectivity table.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.hits">
<code class="descname">hits</code><span class="sig-paren">(</span><em>entities</em>, <em>level</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.hits" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the lower entities from a list connected to the elements.</p>
<p><cite>entities</cite>: a single number or a list/array of entities
<cite>level</cite>: 0 or 1 or 2 if entities are nodes or edges or faces, respectively.</p>
<p>The numbering of the entities corresponds to self.insertLevel(level).
Returns an (nelems,) shaped int array with the number of the
entities from the list that are contained in each of the elements.
This method can be used in selector expressions like:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hits</span><span class="p">(</span><span class="n">entities</span><span class="p">,</span><span class="n">level</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.splitRandom">
<code class="descname">splitRandom</code><span class="sig-paren">(</span><em>n</em>, <em>compact=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.splitRandom" title="Permalink to this definition">¶</a></dt>
<dd><p>Split a Mesh in n parts, distributing the elements randomly.</p>
<p>Returns a list of n Mesh objects, constituting together the same
Mesh as the original. The elements are randomly distributed over
the subMeshes.</p>
<p>By default, the Meshes are compacted. Compaction may be switched
off for efficiency reasons.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.reverse">
<code class="descname">reverse</code><span class="sig-paren">(</span><em>sel=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Mesh where the elements have been reversed.</p>
<p>Reversing an element has the following meaning:</p>
<ul class="simple">
<li>for 1D elements: reverse the traversal direction,</li>
<li>for 2D elements: reverse the direction of the positive normal,</li>
<li>for 3D elements: reverse inside and outside directions of the
element&#8217;s border surface. This also changes the sign of the
elementt&#8217;s volume.</li>
</ul>
<p>The <a class="reference internal" href="#mesh.Mesh.reflect" title="mesh.Mesh.reflect"><code class="xref py py-meth docutils literal"><span class="pre">reflect()</span></code></a> method by default calls this method to undo
the element reversal caused by the reflection operation.</p>
<p>Parameters:</p>
<p>-<cite>sel</cite>: a selector (index or True/False array)</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.reflect">
<code class="descname">reflect</code><span class="sig-paren">(</span><em>dir=0</em>, <em>pos=0.0</em>, <em>reverse=True</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.reflect" title="Permalink to this definition">¶</a></dt>
<dd><p>Reflect the coordinates in one of the coordinate directions.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: int: direction of the reflection (default 0)</li>
<li><cite>pos</cite>: float: offset of the mirror plane from origin (default 0.0)</li>
<li><cite>reverse</cite>: boolean: if True, the <a class="reference internal" href="#mesh.Mesh.reverse" title="mesh.Mesh.reverse"><code class="xref py py-meth docutils literal"><span class="pre">Mesh.reverse()</span></code></a> method is
called after the reflection to undo the element reversal caused
by the reflection of its coordinates. This will in most cases have
the desired effect. If not however, the user can set this to False
to skip the element reversal.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.convert">
<code class="descname">convert</code><span class="sig-paren">(</span><em>totype</em>, <em>fuse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.convert" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a Mesh to another element type.</p>
<p>Converting a Mesh from one element type to another can only be
done if both element types are of the same dimensionality.
Thus, 3D elements can only be converted to 3D elements.</p>
<p>The conversion is done by splitting the elements in smaller parts
and/or by adding new nodes to the elements.</p>
<p>Not all conversions between elements of the same dimensionality
are possible. The possible conversion strategies are implemented
in a table. New strategies may be added however.</p>
<p>The return value is a Mesh of the requested element type, representing
the same geometry (possibly approximatively) as the original mesh.</p>
<p>If the requested conversion is not implemented, an error is raised.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Conversion strategies that add new nodes may produce
double nodes at the common border of elements. The <a class="reference internal" href="#mesh.Mesh.fuse" title="mesh.Mesh.fuse"><code class="xref py py-meth docutils literal"><span class="pre">fuse()</span></code></a>
method can be used to merge such coincident nodes. Specifying
fuse=True will also enforce the fusing. This option become the
default in future.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.convertRandom">
<code class="descname">convertRandom</code><span class="sig-paren">(</span><em>choices</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.convertRandom" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert choosing randomly between choices</p>
<p>Returns a Mesh obtained by converting the current Mesh by a
randomly selected method from the available conversion type
for the current element type.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.subdivide">
<code class="descname">subdivide</code><span class="sig-paren">(</span><em>*ndiv</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.subdivide" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivide the elements of a Mesh.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>ndiv</cite>: specifies the number (and place) of divisions (seeds)
along the edges of the elements. Accepted type and value depend
on the element type of the Mesh. Currently implemented:<ul>
<li>&#8216;tri3&#8217;: ndiv is a single int value specifying the number of
divisions (of equal size) for each edge.</li>
<li>&#8216;quad4&#8217;: ndiv is a sequence of two int values nx,ny, specifying
the number of divisions along the first, resp. second
parametric direction of the element</li>
<li>&#8216;hex8&#8217;: ndiv is a sequence of three int values nx,ny,nz specifying
the number of divisions along the first, resp. second and the third
parametric direction of the element</li>
</ul>
</li>
<li><cite>fuse</cite>: bool, if True (default), the resulting Mesh is completely
fused. If False, the Mesh is only fused over each individual
element of the original Mesh.</li>
</ul>
<p>Returns a Mesh where each element is replaced by a number of
smaller elements of the same type.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is currently only implemented for Meshes of type &#8216;tri3&#8217;
and &#8216;quad4&#8217; and &#8216;hex8&#8217; and for the derived class &#8216;TriSurface&#8217;.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.reduceDegenerate">
<code class="descname">reduceDegenerate</code><span class="sig-paren">(</span><em>eltype=None</em>, <em>return_indices=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.reduceDegenerate" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduce degenerate elements to lower plexitude elements.</p>
<p>This will try to reduce the degenerate elements of the mesh to elements
of a lower plexitude.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>-<cite>eltype</cite>: string. Element type name. If a target element</dt>
<dd>type is given, only the matching reduce scheme is tried.
Else, all the target element types for which a reduce
scheme from the Mesh eltype is available, will be tried.</dd>
<dt>-<cite>return_indices</cite>: bool. If True a list of indices of element positions</dt>
<dd>in the original Mesh(for every intermediate Mesh) is also returned.</dd>
</dl>
<p>The result is a list of Meshes of which the last one contains the
elements that could not be reduced and may be empty.
Property numbers propagate to the children. If return_indices</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.splitDegenerate">
<code class="descname">splitDegenerate</code><span class="sig-paren">(</span><em>autofix=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.splitDegenerate" title="Permalink to this definition">¶</a></dt>
<dd><p>Split a Mesh in degenerate and non-degenerate elements.</p>
<p>If autofix is True, the degenerate elements will be tested against
known degeneration patterns, and the matching elements will be
transformed to non-degenerate elements of a lower plexitude.</p>
<p>The return value is a list of Meshes. The first holds the
non-degenerate elements of the original Mesh. The last holds
the remaining degenerate elements.
The intermediate Meshes, if any, hold elements
of a lower plexitude than the original. These may still contain
degenerate elements.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.removeDegenerate">
<code class="descname">removeDegenerate</code><span class="sig-paren">(</span><em>eltype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.removeDegenerate" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the degenerate elements from a Mesh.</p>
<p>Returns a Mesh with all degenerate elements removed.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.removeDuplicate">
<code class="descname">removeDuplicate</code><span class="sig-paren">(</span><em>permutations=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.removeDuplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the duplicate elements from a Mesh.</p>
<p>Duplicate elements are elements that consist of the same nodes,
by default in no particular order. Setting permutations=False will
only consider elements with the same nodes in the same order as
duplicates.</p>
<p>Returns a Mesh with all duplicate elements removed.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.renumber">
<code class="descname">renumber</code><span class="sig-paren">(</span><em>order='elems'</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.renumber" title="Permalink to this definition">¶</a></dt>
<dd><p>Renumber the nodes of a Mesh in the specified order.</p>
<p>order is an index with length equal to the number of nodes. The
index specifies the node number that should come at this position.
Thus, the order values are the old node numbers on the new node
number positions.</p>
<p>order can also be a predefined value that will generate the node
index automatically:</p>
<ul class="simple">
<li>&#8216;elems&#8217;: the nodes are number in order of their appearance in the
Mesh connectivity.</li>
<li>&#8216;random&#8217;: the nodes are numbered randomly.</li>
<li>&#8216;front&#8217;: the nodes are numbered in order of their frontwalk.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.reorder">
<code class="descname">reorder</code><span class="sig-paren">(</span><em>order='nodes'</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.reorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Reorder the elements of a Mesh.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>order</cite>: either a 1-D integer array with a permutation of
<code class="docutils literal"><span class="pre">arange(self.nelems())</span></code>, specifying the requested order, or one of
the following predefined strings:<ul>
<li>&#8216;nodes&#8217;: order the elements in increasing node number order.</li>
<li>&#8216;random&#8217;: number the elements in a random order.</li>
<li>&#8216;reverse&#8217;: number the elements in reverse order.</li>
</ul>
</li>
</ul>
<p>Returns a Mesh equivalent with self but with the elements ordered as
specified.</p>
<p>See also: <code class="xref py py-meth docutils literal"><span class="pre">Connectivity.reorder()</span></code></p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.renumberElems">
<code class="descname">renumberElems</code><span class="sig-paren">(</span><em>order='nodes'</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.renumberElems" title="Permalink to this definition">¶</a></dt>
<dd><p>Reorder the elements of a Mesh.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>order</cite>: either a 1-D integer array with a permutation of
<code class="docutils literal"><span class="pre">arange(self.nelems())</span></code>, specifying the requested order, or one of
the following predefined strings:<ul>
<li>&#8216;nodes&#8217;: order the elements in increasing node number order.</li>
<li>&#8216;random&#8217;: number the elements in a random order.</li>
<li>&#8216;reverse&#8217;: number the elements in reverse order.</li>
</ul>
</li>
</ul>
<p>Returns a Mesh equivalent with self but with the elements ordered as
specified.</p>
<p>See also: <code class="xref py py-meth docutils literal"><span class="pre">Connectivity.reorder()</span></code></p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.connect">
<code class="descname">connect</code><span class="sig-paren">(</span><em>coordslist</em>, <em>div=1</em>, <em>degree=1</em>, <em>loop=False</em>, <em>eltype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect a sequence of toplogically congruent Meshes into a hypermesh.</p>
<p>Parameters:</p>
<ul>
<li><p class="first"><cite>coordslist</cite>: either a list of Coords objects, or a list of
Mesh objects or a single Mesh object.</p>
<p>If Mesh objects are given, they should (all) have the same element
type as <cite>self</cite>. Their connectivity tables will not be used though.
They will only serve to construct a list of Coords objects by
taking the <cite>coords</cite> attribute of each of the Meshes. If only a single
Mesh was specified, <cite>self.coords</cite> will be added as the first Coords
object in the list.</p>
<p>All Coords objects in the coordslist (either specified or
constructed from the Mesh objects), should have the exact same
shape as <cite>self.coords</cite>. The number of Coords items in the list should
be a multiple of <cite>degree</cite>, plus 1.</p>
<p>Each of the Coords in the final coordslist is combined with the
connectivity table, element type and property numbers of <cite>self</cite> to
produce a list of toplogically congruent meshes.
The return value is the hypermesh obtained by connecting
each consecutive slice of (degree+1) of these meshes. The hypermesh
has a dimensionality that is one higher than the original Mesh (i.e.
points become lines, lines become surfaces, surfaces become volumes).
The resulting elements will be of the given <cite>degree</cite> in the
direction of the connection.</p>
<p>Notice that unless a single Mesh was specified as coordslist, the
coords of <cite>self</cite> are not used. In many cases however <cite>self</cite> or
<cite>self.coords</cite> will be one of the items in the specified <cite>coordslist</cite>.</p>
</li>
<li><p class="first"><cite>degree</cite>: degree of the connection. Currently only degree 1 and 2
are supported.</p>
<ul>
<li><p class="first">If degree is 1, every Coords from the <cite>coordslist</cite>
is connected with hyperelements of a linear degree in the
connection direction.</p>
</li>
<li><p class="first">If degree is 2, quadratic hyperelements are
created from one Coords item and the next two in the list.
Note that all Coords items should contain the same number of nodes,
even for higher order elements where the intermediate planes
contain less nodes.</p>
<p>Currently, degree=2 is not allowed when <cite>coordslist</cite> is specified
as a single Mesh.</p>
</li>
</ul>
</li>
<li><p class="first"><cite>loop</cite>: if True, the connections with loop around the list and
connect back to the first. This is accomplished by adding the first
Coords item back at the end of the list.</p>
</li>
<li><p class="first"><cite>div</cite>: This should only be used for degree==1.</p>
<p>With this parameter the generated connections can be further
subdivided along the connection direction. <cite>div</cite> is either a
single input for the <a class="reference internal" href="#mesh.smartSeed" title="mesh.smartSeed"><code class="xref py py-func docutils literal"><span class="pre">smartSeed()</span></code></a> function, or a list thereof.
In the latter case, the length of the list should be one less
than the length of the <cite>coordslist</cite>. Each pair of consecutive
items from the coordinate list will be connected using the
seeds generated by the corresponding value from <cite>div</cite>, passed to
<a class="reference internal" href="#mesh.smartSeed" title="mesh.smartSeed"><code class="xref py py-func docutils literal"><span class="pre">smartSeed()</span></code></a> with <cite>start=1</cite> parameter. Notice that if seed
values are specified directly as a list of floats, the list
should not contain the first value (0.0), while the final value
should be 1.0.</p>
</li>
<li><p class="first"><cite>eltype</cite>: the element type of the constructed hypermesh. Normally,
this is set automatically from the base element type and the
connection degree. If a different element type is specified,
a final conversion to the requested element type is attempted.</p>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.extrude">
<code class="descname">extrude</code><span class="sig-paren">(</span><em>div</em>, <em>dir=0</em>, <em>length=1.0</em>, <em>degree=1</em>, <em>eltype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.extrude" title="Permalink to this definition">¶</a></dt>
<dd><p>Extrude a Mesh along a straight line.</p>
<p>The Mesh is extruded over a given length in the given direction.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>div</cite>: a value accepted as input by the <a class="reference internal" href="#mesh.smartSeed" title="mesh.smartSeed"><code class="xref py py-func docutils literal"><span class="pre">smartSeed()</span></code></a> function.
It specifies how the extruded direction will be subdivided in
elements.</li>
<li><cite>dir</cite>: the direction of the extrusion: either a global axis
number or a direction vector.</li>
<li><cite>length</cite>: the length of the extrusion, measured along the direction
<cite>dir</cite>.</li>
</ul>
<p>Returns the Mesh obtained by extruding the input Mesh over the
given <cite>length</cite> in direction <cite>dir</cite>, subdividing this length according
to the seeds specified by <cite>dir</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.revolve">
<code class="descname">revolve</code><span class="sig-paren">(</span><em>n</em>, <em>axis=0</em>, <em>angle=360.0</em>, <em>around=None</em>, <em>loop=False</em>, <em>eltype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.revolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Revolve a Mesh around an axis.</p>
<p>Returns a new Mesh obtained by revolving the given Mesh
over an angle around an axis in n steps, while extruding
the mesh from one step to the next.
This extrudes points into lines, lines into surfaces and surfaces
into volumes.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.sweep">
<code class="descname">sweep</code><span class="sig-paren">(</span><em>path</em>, <em>eltype=None</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Sweep a mesh along a path, creating an extrusion</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>path</cite>: Curve object. The path over which to sweep the Mesh.</li>
<li><cite>eltype</cite>: string. Name of the element type on the
returned Meshes.</li>
<li><cite>**kargs</cite>: keyword arguments that are passed to
func:<cite>coords.sweepCoords</cite>, with the same meaning.
Usually, you will need to at least set the <cite>normal</cite> parameter.</li>
</ul>
<p>Returns a Mesh obtained by sweeping the given Mesh over a path.
The returned Mesh has double plexitude of the original.
If <cite>path</cite> is a closed Curve connect back to the first.</p>
<p>This operation is similar to the extrude() method, but the path
can be any 3D curve.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.smooth">
<code class="descname">smooth</code><span class="sig-paren">(</span><em>iterations=1</em>, <em>lamb=0.5</em>, <em>k=0.1</em>, <em>edg=True</em>, <em>exclnod=[]</em>, <em>exclelem=[]</em>, <em>weight=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a smoothed mesh.</p>
<p>Smoothing algorithm based on lowpass filters.</p>
<p>If edg is True, the algorithm tries to smooth the
outer border of the mesh seperately to reduce mesh shrinkage.</p>
<p>Higher values of k can reduce shrinkage even more
(up to a point where the mesh expands),
but will result in less smoothing per iteration.</p>
<ul class="simple">
<li><cite>exclnod</cite>: It contains a list of node indices to exclude from the smoothing.
If exclnod is &#8216;border&#8217;, all nodes on the border of the mesh will
be unchanged, and the smoothing will only act inside.
If exclnod is &#8216;inner&#8217;, only the nodes on the border of the mesh will
take part to the smoothing.</li>
<li><cite>exclelem</cite>: It contains a list of elements to exclude from the smoothing.
The nodes of these elements will not take part to the smoothing.
If exclnod and exclelem are used at the same time the union of them
will be exluded from smoothing.</li>
</ul>
<dl class="docutils">
<dt>-<cite>weight</cite></dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">it is a string  that can assume 2 values <cite>inversedistance</cite> and</span><dd><cite>distance</cite>. It allows to specify the weight of the adjancent points according
to their distance to the point</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="mesh.Mesh.concatenate">
<em class="property">classmethod </em><code class="descname">concatenate</code><span class="sig-paren">(</span><em>clas</em>, <em>meshes</em>, <em>fuse=True</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate a list of meshes of the same plexitude and eltype</p>
<p>All Meshes in the list should have the same plexitude.
Meshes with plexitude are ignored though, to allow empty
Meshes to be added in.</p>
<p>Merging of the nodes can be tuned by specifying extra arguments
that will be passed to <code class="xref py py-meth docutils literal"><span class="pre">Coords:fuse()</span></code>.</p>
<p>If any of the meshes has property numbers, the resulting mesh will
inherit the properties. In that case, any meshes without properties
will be assigned property 0.
If all meshes are without properties, so will be the result.</p>
<p>This is a class method, and should be invoked as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Mesh</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">mesh0</span><span class="p">,</span><span class="n">mesh1</span><span class="p">,</span><span class="n">mesh2</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.test">
<code class="descname">test</code><span class="sig-paren">(</span><em>nodes='all'</em>, <em>dir=0</em>, <em>min=None</em>, <em>max=None</em>, <em>atol=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.test" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag elements having nodal coordinates between min and max.</p>
<p>This function is very convenient in clipping a Mesh in a specified
direction. It returns a 1D integer array flagging (with a value 1 or
True) the elements having nodal coordinates in the required range.
Use where(result) to get a list of element numbers passing the test.
Or directly use clip() or cclip() to create the clipped Mesh</p>
<p>The test plane can be defined in two ways, depending on the value of dir.
If dir == 0, 1 or 2, it specifies a global axis and min and max are
the minimum and maximum values for the coordinates along that axis.
Default is the 0 (or x) direction.</p>
<p>Else, dir should be compaitble with a (3,) shaped array and specifies
the direction of the normal on the planes. In this case, min and max
are points and should also evaluate to (3,) shaped arrays.</p>
<p>nodes specifies which nodes are taken into account in the comparisons.
It should be one of the following:</p>
<ul class="simple">
<li>a single (integer) point number (&lt; the number of points in the Formex)</li>
<li>a list of point numbers</li>
<li>one of the special strings: &#8216;all&#8217;, &#8216;any&#8217;, &#8216;none&#8217;</li>
</ul>
<p>The default (&#8216;all&#8217;) will flag all the elements that have all their
nodes between the planes x=min and x=max, i.e. the elements that
fall completely between these planes. One of the two clipping planes
may be left unspecified.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.clipAtPlane">
<code class="descname">clipAtPlane</code><span class="sig-paren">(</span><em>p</em>, <em>n</em>, <em>nodes='any'</em>, <em>side='+'</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.clipAtPlane" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Mesh clipped at plane (p,n).</p>
<p>This is a convenience function returning the part of the Mesh
at one side of the plane (p,n)</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.intersectionWithLines">
<code class="descname">intersectionWithLines</code><span class="sig-paren">(</span><em>approximated=True</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.intersectionWithLines" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the intersections of a level-2 Mesh with lines.</p>
<p>The Mesh is intersected with lines. The arguments and return values are
the same as in <code class="xref py py-meth docutils literal"><span class="pre">TriSurface.intersectionWithLines()</span></code>, except for
the <cite>approximated</cite>.</p>
<p>For a Mesh with eltype &#8216;tri3&#8217;, the intersections are exact. For other
eltypes, if <cite>approximated</cite> is True a conversion to &#8216;tri3&#8217; is done before
computing the intersections. This may produce an exact result,
an approximate result or no result (if the conversion fails).</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.levelVolumes">
<code class="descname">levelVolumes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.levelVolumes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the level volumes of all elements in a Mesh.</p>
<p>The level volume of an element is defined as:</p>
<ul class="simple">
<li>the length of the element if the Mesh is of level 1,</li>
<li>the area of the element if the Mesh is of level 2,</li>
<li>the (signed) volume of the element if the Mesh is of level 3.</li>
</ul>
<p>The level volumes can be computed directly for Meshes of eltypes
&#8216;line2&#8217;, &#8216;tri3&#8217; and &#8216;tet4&#8217; and will produce accurate results.
All other Mesh types are converted to one of these before computing
the level volumes. Conversion may result in approximation of the
results. If conversion can not be performed, None is returned.</p>
<p>If succesful, returns an (nelems,) float array with the level
volumes of the elements.
Returns None if the Mesh level is 0, or the conversion to the
level&#8217;s base element was unsuccesful.</p>
<p>Note that for level-3 Meshes, negative volumes will be returned
for elements having a reversed node ordering.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.lengths">
<code class="descname">lengths</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.lengths" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the length of all elements in a level-1 Mesh.</p>
<p>For a Mesh with eltype &#8216;line2&#8217;, the lengths are exact. For other
eltypes, a conversion to &#8216;line2&#8217; is done before computing the lengths.
This may produce an exact result, an approximated result or no result
(if the conversion fails).</p>
<p>If succesful, returns an (nelems,) float array with the lengths.
Returns None if the Mesh level is not 1, or the conversion to &#8216;line2&#8217;
does not succeed.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.areas">
<code class="descname">areas</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.areas" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the area of all elements in a level-2 Mesh.</p>
<p>For a Mesh with eltype &#8216;tri3&#8217;, the areas are exact. For other
eltypes, a conversion to &#8216;tri3&#8217; is done before computing the areas.
This may produce an exact result, an approximate result or no result
(if the conversion fails).</p>
<p>If succesful, returns an (nelems,) float array with the areas.
Returns None if the Mesh level is not 2, or the conversion to &#8216;tri3&#8217;
does not succeed.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.volumes">
<code class="descname">volumes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.volumes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the signed volume of all the mesh elements</p>
<p>For a &#8216;tet4&#8217; tetraeder Mesh, the volume of the elements is calculated
as 1/3 * surface of base * height.</p>
<p>For other Mesh types the volumes are calculated by first splitting
the elements into tetraeder elements.</p>
<p>The return value is an array of float values with length equal to the
number of elements.
If the Mesh conversion to tetraeder does not succeed, the return
value is None.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.length">
<code class="descname">length</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.length" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total length of a Mesh.</p>
<p>Returns the sum of self.lengths(), or 0.0 if the self.lengths()
returned None.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.area">
<code class="descname">area</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.area" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total area of a Mesh.</p>
<p>Returns the sum of self.areas(), or 0.0 if the self.areas()
returned None.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.volume">
<code class="descname">volume</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total volume of a Mesh.</p>
<p>For a Mesh of level &lt; 3, a value 0.0 is returned.
For a Mesh of level 3, the volume is computed by converting its
border to a surface and taking the volume inside that surface.
It is equivalent with</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">toSurface</span><span class="p">()</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span>
</pre></div>
</div>
<p>This is far more efficient than <cite>self.volumes().sum()</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.fixVolumes">
<code class="descname">fixVolumes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.fixVolumes" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse the elements with negative volume.</p>
<p>Elements with negative volume may result from incorrect
local node numbering. This method will reverse all elements
in a Mesh of dimensionality 3, provide the volumes of these
elements can be computed.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.addField">
<code class="descname">addField</code><span class="sig-paren">(</span><em>fldtype</em>, <em>data</em>, <em>fldname</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.addField" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a data field to the geometry.</p>
<p>Add a scalar or vectorial field defined over the domain of the
Geometry. This creates a <a class="reference internal" href="field.html#field.Field" title="field.Field"><code class="xref py py-class docutils literal"><span class="pre">field.Field</span></code></a> instance with the specified
parameters and adds it to the Geometry object.
Fields stored inside a Geometry object are exported to PGF file
whenever the object is exported.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>fldtype</cite>, <cite>data</cite>, <cite>fldname</cite>: are passed together with the
Geometry object to the Field initialization. See <a class="reference internal" href="field.html#field.Field" title="field.Field"><code class="xref py py-class docutils literal"><span class="pre">field.Field</span></code></a>
for details.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.addNoise">
<code class="descname">addNoise</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.addNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;addNoise&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.addNoise" title="coords.Coords.addNoise"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.addNoise()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.adjust">
<code class="descname">adjust</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.adjust" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;adjust&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.adjust" title="coords.Coords.adjust"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.adjust()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.affine">
<code class="descname">affine</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;affine&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.affine" title="coords.Coords.affine"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.affine()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.align">
<code class="descname">align</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.align" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;align&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.align" title="coords.Coords.align"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.align()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.bump">
<code class="descname">bump</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.bump" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;bump&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.bump" title="coords.Coords.bump"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.bump()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.bump1">
<code class="descname">bump1</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.bump1" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;bump1&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.bump1" title="coords.Coords.bump1"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.bump1()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.bump2">
<code class="descname">bump2</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.bump2" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;bump2&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.bump2" title="coords.Coords.bump2"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.bump2()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.cclip">
<code class="descname">cclip</code><span class="sig-paren">(</span><em>*_args</em>, <em>**_kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.cclip" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Geometry with the selected elements removed.</p>
<p>For a Formex, this is equivalent with cselect(sel).
For a Mesh, this is equivalent with cselect(sel,compact=True).</p>
<p>See <a class="reference internal" href="#mesh.Mesh.cselect" title="mesh.Mesh.cselect"><code class="xref py py-meth docutils literal"><span class="pre">cselect()</span></code></a> for more information.</p>
<p>This is the complimentary operation of <a class="reference internal" href="#mesh.Mesh.clip" title="mesh.Mesh.clip"><code class="xref py py-meth docutils literal"><span class="pre">clip()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.centered">
<code class="descname">centered</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.centered" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;centered&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.centered" title="coords.Coords.centered"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.centered()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.clip">
<code class="descname">clip</code><span class="sig-paren">(</span><em>*_args</em>, <em>**_kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Geometry only containing the selected elements.</p>
<p>For a Formex, this is equivalent with select(sel).
For a Mesh, this is equivalent with select(sel,compact=True).</p>
<p>See <a class="reference internal" href="#mesh.Mesh.select" title="mesh.Mesh.select"><code class="xref py py-meth docutils literal"><span class="pre">select()</span></code></a> for more information.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.convertField">
<code class="descname">convertField</code><span class="sig-paren">(</span><em>fldname</em>, <em>totype</em>, <em>toname</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.convertField" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the data field with the specified name.</p>
<p>If the data field does not exist, returns None</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.convexHull">
<code class="descname">convexHull</code><span class="sig-paren">(</span><em>dir=None</em>, <em>return_mesh=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.convexHull" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the convex hull of a Coords.</p>
<p>This works like <code class="xref py py-meth docutils literal"><span class="pre">Coords.convexHull()</span></code>, but has return_mesh=True
as default. It is equivalent with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">convexHull</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span><span class="n">return_mesh</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the Geometry  object.</p>
<p>The returned object is an exact copy of the input, but has
all of its data independent of the former.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.cselect">
<code class="descname">cselect</code><span class="sig-paren">(</span><em>*_args</em>, <em>**_kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.cselect" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Geometry with the selected elements removed.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>sel</cite>: an object that can be used as an index in an array:<ul>
<li>a single element number</li>
<li>a list, or array, of element numbers</li>
<li>a bool list, or array, of length self.nelems(), where True values
flag the elements to be selected</li>
</ul>
</li>
<li><cite>compact</cite>: boolean. Only useful for Mesh type Geometries.
If True (default), the returned Mesh will be compacted, i.e.
the unused nodes are removed and the nodes are renumbered from
zero. If False, returns the node set and numbers unchanged.</li>
<li><cite>sel</cite>: an object that can be used as an index in the
<cite>elems</cite> array, such as<ul>
<li>a single element number</li>
<li>a list, or array, of element numbers</li>
<li>a bool list, or array, of length self.nelems(), where True values
flag the elements to be selected</li>
</ul>
</li>
<li><cite>compact</cite>: boolean. Only useful for Mesh type Geometries.
If True (default), the returned Mesh will be compacted, i.e.
the unused nodes are removed and the nodes are renumbered from
zero. If False, returns the node set and numbers unchanged.</li>
</ul>
<p>Returns a Geometry (or subclass) with all but the selected elements.</p>
<p>This is the complimentary operation of <a class="reference internal" href="#mesh.Mesh.select" title="mesh.Mesh.select"><code class="xref py py-meth docutils literal"><span class="pre">select()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.cselectProp">
<code class="descname">cselectProp</code><span class="sig-paren">(</span><em>val</em>, <em>compact=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.cselectProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an object without the elements with property <cite>val</cite>.</p>
<p>This is the complementary method of selectProp.
val is either a single integer, or a list/array of integers.
The return value is a object holding all the elements that do not
have the property val, resp. one of the values in val.
The returned object inherits the matching properties.</p>
<p>If the object has no properties, a copy with all elements is returned.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.cylindrical">
<code class="descname">cylindrical</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.cylindrical" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;cylindrical&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.cylindrical" title="coords.Coords.cylindrical"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.cylindrical()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.delField">
<code class="descname">delField</code><span class="sig-paren">(</span><em>fldname</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.delField" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the Field with the given name.</p>
<p>A nonexisting name is silently ignored.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.egg">
<code class="descname">egg</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.egg" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;egg&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.egg" title="coords.Coords.egg"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.egg()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.fieldReport">
<code class="descname">fieldReport</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.fieldReport" title="Permalink to this definition">¶</a></dt>
<dd><p>Print a short report of the stored fields</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.flare">
<code class="descname">flare</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.flare" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;flare&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.flare" title="coords.Coords.flare"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.flare()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.fromCS">
<code class="descname">fromCS</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.fromCS" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;fromCS&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.fromCS" title="coords.Coords.fromCS"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.fromCS()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.getField">
<code class="descname">getField</code><span class="sig-paren">(</span><em>fldname</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.getField" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the data field with the specified name.</p>
<p>If the data field does not exist, returns None</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.hyperCylindrical">
<code class="descname">hyperCylindrical</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.hyperCylindrical" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;hyperCylindrical&#8217; transformation to the Geometry object.</p>
<p>See <code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.hyperCylindrical()</span></code> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.isopar">
<code class="descname">isopar</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.isopar" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;isopar&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.isopar" title="coords.Coords.isopar"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.isopar()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.map">
<code class="descname">map</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.map" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;map&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.map" title="coords.Coords.map"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.map()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.map1">
<code class="descname">map1</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.map1" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;map1&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.map1" title="coords.Coords.map1"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.map1()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.mapd">
<code class="descname">mapd</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.mapd" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;mapd&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.mapd" title="coords.Coords.mapd"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.mapd()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.position">
<code class="descname">position</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.position" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;position&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.position" title="coords.Coords.position"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.position()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.projectOnCylinder">
<code class="descname">projectOnCylinder</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.projectOnCylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;projectOnCylinder&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.projectOnCylinder" title="coords.Coords.projectOnCylinder"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.projectOnCylinder()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.projectOnPlane">
<code class="descname">projectOnPlane</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.projectOnPlane" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;projectOnPlane&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.projectOnPlane" title="coords.Coords.projectOnPlane"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.projectOnPlane()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.projectOnSphere">
<code class="descname">projectOnSphere</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.projectOnSphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;projectOnSphere&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.projectOnSphere" title="coords.Coords.projectOnSphere"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.projectOnSphere()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.read">
<code class="descname">read</code><span class="sig-paren">(</span><em>clas</em>, <em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a Geometry from a PGF file.</p>
<p>This reads a single object (the object) from a PGF file
and returns it.</p>
<p>It is a convenient shorthand for:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">readGeomFile</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.replace">
<code class="descname">replace</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;replace&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.replace" title="coords.Coords.replace"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.replace()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.resized">
<code class="descname">resized</code><span class="sig-paren">(</span><em>size=1.0</em>, <em>tol=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.resized" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the Geometry scaled to the given size.</p>
<p>size can be a single value or a list of three values for the
three coordinate directions. If it is a single value, all directions
are scaled to the same size.
Directions for which the geometry has a size smaller than tol times
the maximum size are not rescaled.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.rollAxes">
<code class="descname">rollAxes</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.rollAxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;rollAxes&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.rollAxes" title="coords.Coords.rollAxes"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.rollAxes()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.rot">
<code class="descname">rot</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.rot" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;rotate&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.rotate" title="coords.Coords.rotate"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.rotate()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;rotate&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.rotate" title="coords.Coords.rotate"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.rotate()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.scale">
<code class="descname">scale</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;scale&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.scale" title="coords.Coords.scale"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.scale()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.select">
<code class="descname">select</code><span class="sig-paren">(</span><em>*_args</em>, <em>**_kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.select" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Geometry only containing the selected elements.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>sel</cite>: an object that can be used as an index in an array:<ul>
<li>a single element number</li>
<li>a list, or array, of element numbers</li>
<li>a bool list, or array, of length self.nelems(), where True values
flag the elements to be selected</li>
</ul>
</li>
<li><cite>compact</cite>: boolean. Only useful for Mesh type Geometries.
If True (default), the returned Mesh will be compacted, i.e.
the unused nodes are removed and the nodes are renumbered from
zero. If False, returns the node set and numbers unchanged.</li>
</ul>
<p>Returns a Geometry (or subclass) with only the selected elements.</p>
<p>See <a class="reference internal" href="#mesh.Mesh.cselect" title="mesh.Mesh.cselect"><code class="xref py py-meth docutils literal"><span class="pre">cselect()</span></code></a> for the complementary operation.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.selectProp">
<code class="descname">selectProp</code><span class="sig-paren">(</span><em>val</em>, <em>compact=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.selectProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an object which holds only the elements with property val.</p>
<p>val is either a single integer, or a list/array of integers.
The return value is a object holding all the elements that
have the property val, resp. one of the values in val.
The returned object inherits the matching properties.</p>
<p>If the object has no properties, a copy with all elements is returned.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.setProp">
<code class="descname">setProp</code><span class="sig-paren">(</span><em>prop=None</em>, <em>blocks=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.setProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Create or destroy the property array for the Geometry.</p>
<p>A property array is a rank-1 integer array with dimension equal
to the number of elements in the Geometry. Each element thus has its
own property number. These numbers can be used for any purpose.
They play an import role when creating new geometry: new elements
inherit the property number of their parent element.
Properties are also preserved on most geometrical transformations.</p>
<p>Because elements with different property numbers can be drawn in
different colors, the property numbers are also often used to impose
color.</p>
<p>Parameters:</p>
<ul>
<li><p class="first"><cite>prop</cite>: a single integer value or a list/array of integer values.
If the number of passed values is less than the number of elements,
they wil be repeated. If you give more, they will be ignored.</p>
<p>The special value &#8216;range&#8217; will set the property numbers
equal to the element number.</p>
<p>A value None (default) removes the properties from the Geometry.</p>
</li>
<li><p class="first"><cite>blocks</cite>: a single integer value or a list/array of integer values.
If the number of passed values is less than the length of <cite>prop</cite>,
they wil be repeated. If you give more, they will be ignored.
Every prop will be repeated the corresponding number of times
specified in blocks.</p>
</li>
</ul>
<dl class="docutils">
<dt>Returns the Geometry with the new properties inserted or with the</dt>
<dd>properties deleted (if argument is None).
Notice that unlike most other Geometry methods, this method changes
(and returns) the existing object.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.shear">
<code class="descname">shear</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.shear" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;shear&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.shear" title="coords.Coords.shear"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.shear()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.spherical">
<code class="descname">spherical</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.spherical" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;spherical&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.spherical" title="coords.Coords.spherical"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.spherical()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.splitProp">
<code class="descname">splitProp</code><span class="sig-paren">(</span><em>prop=None</em>, <em>compact=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.splitProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Partition a Geometry (Formex/Mesh) according to the values in prop.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>prop</cite>: an int array with length self.nelems(), or None. If None,
the <cite>prop</cite> attribute of the Geometry is used.</li>
</ul>
<p>Returns a list of Geometry objects of the same type as the input.
Each object contains all the elements having the same value of <cite>prop</cite>.
The number of objects in the list is equal to the number of unique
values in <cite>prop</cite>. The list is sorted in ascending order of their
<cite>prop</cite> value.</p>
<p>If <cite>prop</cite> is None and the the object has no <cite>prop</cite> attribute, an empty
list is returned.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.superSpherical">
<code class="descname">superSpherical</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.superSpherical" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;superSpherical&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.superSpherical" title="coords.Coords.superSpherical"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.superSpherical()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.swapAxes">
<code class="descname">swapAxes</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.swapAxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;swapAxes&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.swapAxes" title="coords.Coords.swapAxes"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.swapAxes()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.toCS">
<code class="descname">toCS</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.toCS" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;toCS&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.toCS" title="coords.Coords.toCS"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.toCS()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.toCylindrical">
<code class="descname">toCylindrical</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.toCylindrical" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;toCylindrical&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.toCylindrical" title="coords.Coords.toCylindrical"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.toCylindrical()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.toProp">
<code class="descname">toProp</code><span class="sig-paren">(</span><em>prop</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.toProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts the argument into a legal set of properties for the object.</p>
<p>The conversion involves resizing the argument to a 1D array of
length self.nelems(), and converting the data type to integer.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.toSpherical">
<code class="descname">toSpherical</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.toSpherical" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;toSpherical&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.toSpherical" title="coords.Coords.toSpherical"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.toSpherical()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.transformCS">
<code class="descname">transformCS</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.transformCS" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;transformCS&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.transformCS" title="coords.Coords.transformCS"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.transformCS()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.translate">
<code class="descname">translate</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;translate&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.translate" title="coords.Coords.translate"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.translate()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.trl">
<code class="descname">trl</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.trl" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply &#8216;translate&#8217; transformation to the Geometry object.</p>
<p>See <a class="reference internal" href="coords.html#coords.Coords.translate" title="coords.Coords.translate"><code class="xref py py-meth docutils literal"><span class="pre">coords.Coords.translate()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.whereProp">
<code class="descname">whereProp</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.whereProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the numbers of the elements with property val.</p>
<p>val is either a single integer, or a list/array of integers.
The return value is an array holding all the numbers of all the
elements that have the property val, resp. one of the values in val.</p>
<p>If the object has no properties, a empty array is returned.</p>
</dd></dl>

<dl class="method">
<dt id="mesh.Mesh.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>filename</em>, <em>sep=' '</em>, <em>mode='w'</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a Geometry to a .pgf file.</p>
<p>This writes the Geometry to a pyFormex Geometry File (PGF) with
the specified name.</p>
<p>It is a convenient shorthand for:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">writeGeomFile</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="functions-defined-in-module-mesh">
<h2>7.2. Functions defined in module mesh<a class="headerlink" href="#functions-defined-in-module-mesh" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="mesh.mergeNodes">
<code class="descclassname">mesh.</code><code class="descname">mergeNodes</code><span class="sig-paren">(</span><em>nodes</em>, <em>fuse=True</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.mergeNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge all the nodes of a list of node sets.</p>
<p>Merging the nodes creates a single Coords object containing all nodes,
and the indices to find the points of the original node sets in the
merged set.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>nodes</cite>: a list of Coords objects, all having the same shape, except
possibly for their first dimension</li>
<li><cite>fuse</cite>: if True (default), coincident (or very close) points will
be fused to a single point</li>
<li><cite>**kargs</cite>: keyword arguments that are passed to the fuse operation</li>
</ul>
<p>Returns:</p>
<ul class="simple">
<li>a Coords with the coordinates of all (unique) nodes,</li>
<li>a list of indices translating the old node numbers to the new. These
numbers refer to the serialized Coords.</li>
</ul>
<p>The merging operation can be tuned by specifying extra arguments
that will be passed to <code class="xref py py-meth docutils literal"><span class="pre">Coords.fuse()</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="mesh.mergeMeshes">
<code class="descclassname">mesh.</code><code class="descname">mergeMeshes</code><span class="sig-paren">(</span><em>meshes</em>, <em>fuse=True</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.mergeMeshes" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge all the nodes of a list of Meshes.</p>
<p>Each item in meshes is a Mesh instance.
The return value is a tuple with:</p>
<ul class="simple">
<li>the coordinates of all unique nodes,</li>
<li>a list of elems corresponding to the input list,
but with numbers referring to the new coordinates.</li>
</ul>
<p>The merging operation can be tuned by specifying extra arguments
that will be passed to <code class="xref py py-meth docutils literal"><span class="pre">Coords:fuse()</span></code>.
Setting fuse=False will merely concatenate all the mesh.coords, but
not fuse them.</p>
</dd></dl>

<dl class="function">
<dt id="mesh.unitAttractor">
<code class="descclassname">mesh.</code><code class="descname">unitAttractor</code><span class="sig-paren">(</span><em>x</em>, <em>e0=0.0</em>, <em>e1=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.unitAttractor" title="Permalink to this definition">¶</a></dt>
<dd><p>Moves values in the range 0..1 closer to or away from the limits.</p>
<ul class="simple">
<li><cite>x</cite>: a list or array with values in the range 0.0 to 1.0.</li>
<li><cite>e0</cite>, <cite>e1</cite>: attractor parameters for the start, resp. the end of the
range. A value larger than zero will attract the points closer to the
corresponding endpoint, while a negative value will repulse them.
If two positive values are given, the middle part of the interval
will become sparsely populated.</li>
</ul>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">unitAttractor</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.25</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.75</span><span class="p">,</span><span class="mf">1.0</span><span class="p">],</span><span class="mf">2.</span><span class="p">))</span>
<span class="go">[ 0.      0.0039  0.0625  0.3164  1.    ]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mesh.seed">
<code class="descclassname">mesh.</code><code class="descname">seed</code><span class="sig-paren">(</span><em>n</em>, <em>e0=0.0</em>, <em>e1=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.seed" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a list of seed values.</p>
<p>A seed list is a list of float values in the range 0.0 to 1.0.
It can be used to subdivide a line segment or to seed nodes
along lines for meshing purposes.</p>
<p>This function divides the unit interval in <cite>n</cite> parts, resulting
in <cite>n+1</cite> seed values. While the intervals are by default of equal
length, the <cite>e0</cite> and <cite>e1</cite> can be used to create unevenly spaced
seed values.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>n</cite>: positive integer: the number of elements (yielding <cite>n+1</cite>
parameter values).</li>
<li><cite>e0</cite>, <cite>e1</cite>: attractor parameters for the start, resp. the end of the
range. A value larger than zero will attract the points closer to the
corresponding endpoint, while a negative value will repulse them.
If two positive values are given, the middle part of the interval
will become sparsely populated.</li>
</ul>
<p>Returns a list of <cite>n+1</cite> float values in the range 0.0 to 1.0.
The values are in ascending order, starting with 0.0 and ending with 1.0.</p>
<p>See also :func: <cite>smartSeed</cite> for an analogue function accepting a variety
of input.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">seed</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mf">2.</span><span class="p">))</span>
<span class="go">[ 0.      0.0639  0.3362  0.6638  0.9361  1.    ]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mesh.smartSeed">
<code class="descclassname">mesh.</code><code class="descname">smartSeed</code><span class="sig-paren">(</span><em>n</em>, <em>start=0</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.smartSeed" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a list of seed values.</p>
<p>Like the <a class="reference internal" href="#mesh.seed" title="mesh.seed"><code class="xref py py-func docutils literal"><span class="pre">seed()</span></code></a> function, this function creates a list of float
values in the range 0.0 to 1.0. It accepts however a variety of inputs,
making it the prefered choice when it is not known in advance how the
user wants to control the seeds: automatically created or self specified.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>n</cite>: can be one of the following:<ul>
<li>a positive integer: returns <cite>seed(n)</cite>,</li>
<li>a tuple (n,), (n,e0) or (n,e0,e1): returns <cite>seed(*n)</cite>,</li>
<li>a list or array of floats: returns the input parameter as is.</li>
</ul>
</li>
<li><cite>start</cite>: 0 or 1: The default (0) makes the full list created by
<cite>seed()</cite> to be returned. If 1, the first value (0.0) is omitted:
this can be useful when creating seeds over multiple adjacent
intervals.</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="mesh.gridpoints">
<code class="descclassname">mesh.</code><code class="descname">gridpoints</code><span class="sig-paren">(</span><em>seed0</em>, <em>seed1=None</em>, <em>seed2=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.gridpoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Create weights for 1D, 2D or 3D element coordinates.</p>
<p>Parameters:</p>
<ul class="simple">
<li>&#8216;seed0&#8217; : int or list of floats . It specifies divisions along
the first parametric direction of the element</li>
<li>&#8216;seed1&#8217; : int or list of floats . It specifies divisions along
the second parametric direction of the element</li>
<li>&#8216;seed2&#8217; : int or list of floats . It specifies divisions along
the t parametric direction of the element</li>
</ul>
<p>If these parametes are integer values the divisions will be equally
spaced between 0 and 1.</p>
</dd></dl>

<dl class="function">
<dt id="mesh.line2_wts">
<code class="descclassname">mesh.</code><code class="descname">line2_wts</code><span class="sig-paren">(</span><em>seed0</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.line2_wts" title="Permalink to this definition">¶</a></dt>
<dd><p>Create weights for line2 subdivision.</p>
<p>Parameters:</p>
<ul class="simple">
<li>&#8216;seed0&#8217; : int or list of floats . It specifies divisions along the
first parametric direction of the element</li>
</ul>
<p>If these parametes are integer values the divisions will be equally spaced between  0 and 1</p>
</dd></dl>

<dl class="function">
<dt id="mesh.quad4_wts">
<code class="descclassname">mesh.</code><code class="descname">quad4_wts</code><span class="sig-paren">(</span><em>seed0</em>, <em>seed1</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.quad4_wts" title="Permalink to this definition">¶</a></dt>
<dd><p>Create weights for quad4 subdivision.</p>
<p>Parameters:</p>
<ul class="simple">
<li>&#8216;seed0&#8217; : int or list of floats . It specifies divisions along the
first parametric direction of the element</li>
<li>&#8216;seed1&#8217; : int or list of floats . It specifies divisions along
the second parametric direction of the element</li>
</ul>
<p>If these parametes are integer values the divisions will be equally spaced between  0 and 1</p>
</dd></dl>

<dl class="function">
<dt id="mesh.quad9_wts">
<code class="descclassname">mesh.</code><code class="descname">quad9_wts</code><span class="sig-paren">(</span><em>seed0</em>, <em>seed1</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.quad9_wts" title="Permalink to this definition">¶</a></dt>
<dd><p>Create weights for quad4 subdivision.</p>
<p>Parameters:</p>
<ul class="simple">
<li>&#8216;seed0&#8217; : int or list of floats . It specifies divisions along the
first parametric direction of the element</li>
<li>&#8216;seed1&#8217; : int or list of floats . It specifies divisions along
the second parametric direction of the element</li>
</ul>
<p>If these parametes are integer values the divisions will be equally spaced between  0 and 1</p>
</dd></dl>

<dl class="function">
<dt id="mesh.quadgrid">
<code class="descclassname">mesh.</code><code class="descname">quadgrid</code><span class="sig-paren">(</span><em>seed0</em>, <em>seed1</em>, <em>roll=0</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.quadgrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a quadrilateral mesh of unit size with the specified seeds.</p>
<p>The seeds are a monotonously increasing series of parametric values
in the range 0..1. They define the positions of the nodes in the
parametric directions 0, resp. 1.
Normally, the first and last values of the seeds are 0., resp. 1.,
leading to a unit square grid.</p>
<p>The seeds are usually generated with the seed() function.</p>
</dd></dl>

<dl class="function">
<dt id="mesh.hex8_wts">
<code class="descclassname">mesh.</code><code class="descname">hex8_wts</code><span class="sig-paren">(</span><em>seed0</em>, <em>seed1</em>, <em>seed2</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.hex8_wts" title="Permalink to this definition">¶</a></dt>
<dd><p>Create weights for hex8 subdivision.</p>
<p>Parameters:</p>
<ul class="simple">
<li>&#8216;seed0&#8217; : int or list of floats . It specifies divisions along the
first parametric direction of the element</li>
<li>&#8216;seed1&#8217; : int or list of floats . It specifies divisions along
the second parametric direction of the element</li>
<li>&#8216;seed2&#8217; : int or list of floats . It specifies divisions along
the t parametric direction of the element</li>
</ul>
<p>If these parametes are integer values the divisions will be equally
spaced between  0 and 1</p>
</dd></dl>

<dl class="function">
<dt id="mesh.hex8_els">
<code class="descclassname">mesh.</code><code class="descname">hex8_els</code><span class="sig-paren">(</span><em>nx</em>, <em>ny</em>, <em>nz</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.hex8_els" title="Permalink to this definition">¶</a></dt>
<dd><p>Create connectivity table for hex8 subdivision.</p>
</dd></dl>

<dl class="function">
<dt id="mesh.rectangle">
<code class="descclassname">mesh.</code><code class="descname">rectangle</code><span class="sig-paren">(</span><em>L</em>, <em>W</em>, <em>nl</em>, <em>nw</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.rectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a plane rectangular mesh of quad4 elements.</p>
<p>Parameters:</p>
<ul class="simple">
<li>nl,nw: seeds for the elements along the length, width of the rectangle.
They should one of the following:<ul>
<li>an integer number, specifying the number of equally sized elements
along that direction,</li>
<li>a tuple (n,) or (n,e0) or (n,e0,e1), to be used as parameters in the
<a class="reference internal" href="#mesh.seed" title="mesh.seed"><code class="xref py py-func docutils literal"><span class="pre">mesh.seed()</span></code></a> function,</li>
<li>a list of float values in the range 0.0 to 1.0, specifying the relative
position of the seeds. The values should be ordered and the first and
last values should be 0.0 and 1.0.</li>
</ul>
</li>
<li>L,W: length,width of the rectangle.</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="mesh.rectangleWithHole">
<code class="descclassname">mesh.</code><code class="descname">rectangleWithHole</code><span class="sig-paren">(</span><em>L</em>, <em>W</em>, <em>r</em>, <em>nr</em>, <em>nl</em>, <em>nw=None</em>, <em>e0=0.0</em>, <em>eltype='quad4'</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.rectangleWithHole" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a quarter of rectangle with a central circular hole.</p>
<p>Parameters:</p>
<ul>
<li><p class="first"><cite>L</cite>: float. Length of the (quarter) rectangle</p>
</li>
<li><p class="first"><cite>W</cite>: float. Width of the (quarter) rectangle</p>
</li>
<li><p class="first"><cite>r</cite>: float. Radius of the hole</p>
</li>
<li><p class="first"><cite>nr</cite>: integer. Number of elements over radial direction</p>
</li>
<li><p class="first"><cite>nl</cite>: integer. Number of elements over tangential direction along L</p>
</li>
<li><dl class="first docutils">
<dt><cite>nw</cite>: integer. Number of elements over tangential direction along W.</dt>
<dd><p class="first last">If None (default), it will be set equal to nl.</p>
</dd>
</dl>
</li>
<li><p class="first"><cite>e0</cite>: float. Concentration factor for elements in the radial direction</p>
</li>
</ul>
<p>Returns a Mesh</p>
</dd></dl>

<dl class="function">
<dt id="mesh.quadrilateral">
<code class="descclassname">mesh.</code><code class="descname">quadrilateral</code><span class="sig-paren">(</span><em>x</em>, <em>n1</em>, <em>n2</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.quadrilateral" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a quadrilateral mesh</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>x</cite>: Coords(4,3): Four corners of the mesh, in anti-clockwise order.</li>
<li><cite>n1</cite>: number of elements along sides x0-x1 and x2-x3</li>
<li><cite>n2</cite>: number of elements along sides x1-x2 and x3-x4</li>
</ul>
<p>Returns a Mesh of quads filling the quadrilateral defined  by the four
points <cite>x</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="mesh.quarterCircle">
<code class="descclassname">mesh.</code><code class="descname">quarterCircle</code><span class="sig-paren">(</span><em>n1</em>, <em>n2</em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.quarterCircle" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a mesh of quadrilaterals filling a quarter circle.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>n1</cite>: number of elements along sides x0-x1 and x2-x3</li>
<li><cite>n2</cite>: number of elements along sides x1-x2 and x3-x4</li>
</ul>
<p>Returns a Mesh representing a quarter circle with radius 1 and
center at the origin.</p>
<p>The quarter circle mesh has a kernel of n1*n1 cells, and two
border meshes of n1*n2 cells. The resulting mesh has n1+n2 cells
in radial direction and 2*n1 cells in tangential direction (in the
border mesh).</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="geometry.html" title="8. geometry — A generic interface to the Coords transformation methods"
             >next</a> |</li>
        <li class="right" >
          <a href="opengl.colors.html" title="6. opengl.colors — Playing with colors."
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">pyFormex 1.0.2-a6 documentation</a> &gt;</li>
          <li class="nav-item nav-item-1"><a href="../refman.html" >pyFormex reference manual</a> &gt;</li> 
      </ul>
    </div>
    <div class="footer">
    <span class="left">
        &copy; Copyright 2004-2015, Benedict Verhegghe.
    </span>
      Last updated on Sep 09, 2016.
    <span class="right">
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.4.5.
    </span>
    </div>
  </body>
</html>